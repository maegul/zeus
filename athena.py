import numpy as np

from circ_stat import circ_stat as cs

import cPickle
import glob

def descs_type_test(descs):

    assert type(descs) == list, 'Descriptions must be a list'
    assert all([type(e) == str for e in descs]), 'Descriptions must be a list of strings'



class athena:
    '''
    Defines the structure and contents of the meta-data for the project
    
    Presumes a single analysis directory.
    
    Saves a file for common reference to that directory.
    

    
    '''

            
    def __init__(self, project_name = None):
        
        if project_name is not None:
            self.project_name = project_name
            
        else:

        	# Can I just instantiate self as the pickled athena object
        	# or iterate over each property and add to self?
        	# really depends on what will be in the file?
        		# prject meta data
        		# all zeus instantiations
        		# all tuning data and calculations
        		# A nested ditionary?
            panth_file_path = glob.glob('*.pantheon')
            
            assert panth_file_path, 'There is no pantheon file for metadata upload'
            
            assert len(panth_file_path) > 1, 'There are multiple pantheon files'
            
            with open(panth_file_path[0], 'r') as f:
            
                self.proj_meta_data = cPickle.load(f)
                
    def _set_proj(self, question, descs=None):
        
        try:
            self.proj_meta_data
            
            print('meta data already loaded')
            
        except AttributeError:
            
            assert type(question) == str, 'question must be a string'
            
            self.question = question

            if descs is not None:
                
                descs_type_test(descs)
                
                descs = [e.lower() for e in descs]
                
                self.descs = descs
                
    def _update_descs(self, update_descs, replace=False):
        
        descs_type_test(update_descs)
        
        try:
            self.descs
            
            update_descs = [e.lower() for e in update_descs]
            
            if replace:
                self.descs = update_descs
            else:
                for e in update_descs:
                    self.descs.append(e)
                    
        except AttributeError:
            print('Must define descriptions before you can update')
            
            
    
    def _zeus_meta_data(self, exp=None, track=None, unit=None, run=None, desc=None):
        
        assert type(exp) == str, 'experiment should be a string'
        assert type(track) == int, 'Track should be integer'
        assert type(unit) == int, 'unit should be integer'
        assert type(run) == int, 'run should be integer'
        
        exp = exp.lower()
        
        
        meta_data_output = dict(project_name = self.project_name,
                    question = self.question,
                    experiment = exp.lower(),
                    track = track,
                    unit = unit,
                    run = run
                   )
    
        try:
            self.descs
            
            if desc is not None:
                assert desc in self.descs, 'desc not prescribed'
                
                meta_data_output.update(desc=desc)

        except AttributeError:
            
            print('There are no prescribed descriptions')
            



            
        return meta_data_output




    def _add_data(self, zeus_instance):

        try:
            zeus_instance.cond_tuning
            
            print('yes')

        except AttributeError:
            
            print('zeus instance has no cond_tuning attribute ... analyse the data first!')
            

        # Master list of all exp, tracks, units etc
        # Check against this list for each new metadata ... checking if matches or not
        # adding where new, with notification
        # function for viewing the lists
            
        return zeus_instance





# Once metadata generated by athena, she remembers, and I can add with a simple funtion
# The function strips the metadata from zeus and incorporates the (relevant) data
# On the zeus side, all the unnecessary data is saved to file using a zeus method, with appropriate file name

 

